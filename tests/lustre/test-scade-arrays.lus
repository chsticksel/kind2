type rational = { n: int; d: int };

const C1 = [1, 2, 3];
const C2 = 1^3;
-- const C3[i] : int^3 = i;

node Y(in: int) returns (out: int^2);
let
  out = in^2;
tel;

node X(s: int; const array_size: int) returns (A8: int^2);
const array_default = 0;
var 
  A1, A2, A7: int^array_size;
  A3, A4: int^array_size^array_size;
  A5: [int, bool]^array_size;
  A6: rational^array_size;
  A9, A10: int^3;
  i: real;
  j: bool;

let

  -- These identifiers are hidden in the array definitions
  i = 0.0;
  j = true;
  
  -- A sliding window over input stream s
  A2[k] = if k = 0 then s else (k -> pre A1[k-1]);
  
  -- A pointwise definition of an array
  A1[i] = array_default;

  -- A multi-dimensional array
  A3[i][j] = s;
  
  -- A multi-dimensional array, the second i masks the first 
  A4[i][i] = i;
  
  -- Structural assignment involving recursive array definition
  -- (i, A1[i]) = (0, s);

  -- Array of tuples 
  -- A5[i] = [ i, i mod 2 = 0 ];

  -- Array of records
  -- A6[i] = rational { n=i; d=i+1 };

  -- Temporal operator applied to running variable: legal?
  A7[i] = 0 -> pre i;

  -- Return an array from a node call
  A8[i] = Y(0)[i];

  -- A9[i] = C1[i] -> pre A9[i] + 1;

  -- A10[i] = C2[i] -> pre A10[i] + 1;

  --%PROPERTY A1[0] + A2[0] + A7[0] = 0;
  --%PROPERTY A3[0][0] + A4[0][0] = 0;
  --%PROPERTY A8[0] = 0;
  --%PROPERTY (int i) > 0;
  --%PROPERTY j;
tel